# Advanced Lane Finding Project

The goals / steps of this project are the following:

* Compute the camera calibration matrix and distortion coefficients given a set of chessboard images.
* Apply a distortion correction to raw images.
* Use color transforms, gradients, etc., to create a thresholded binary image.
* Apply a perspective transform to rectify binary image ("birds-eye view").
* Detect lane pixels and fit to find the lane boundary.
* Determine the curvature of the lane and vehicle position with respect to center.
* Warp the detected lane boundaries back onto the original image.
* Output visual display of the lane boundaries and numerical estimation of lane curvature and vehicle position.

[//]: # (Image References)

[image1]: ./output_images/cal_test.png "Undistorted"
[image2]: ./output_images/undist_test.jpg "Road Transformed"
[image3]: ./output_images/color_test.png "Binary Example"
[image4]: ./output_images/birds_eye_test.png "Warp Example"
[image5]: ./output_images/find_lane_test_curve_poly.png "Fit Visual"
[image6]: ./output_images/pipeline_test.jpg "Output"
[video1]: ./output_images/project_video_output.mp4 "Video"
[video1]: ./output_images/challenge_video_output.mp4 "Video"
[video1]: ./output_images/harder_video_output.mp4 "Video"

## [Rubric](https://review.udacity.com/#!/rubrics/571/view) Points

### Here I will consider the rubric points individually and describe how I addressed each point in my implementation.  

---

You can find my code in `./Lane_line.ipynb`.

### Writeup / README

#### 1. Provide a Writeup / README that includes all the rubric points and how you addressed each one.

You're reading it!

### Camera Calibration

#### 1. Briefly state how you computed the camera matrix and distortion coefficients. Provide an example of a distortion corrected calibration image.

First, calculate `objpoints`, `imgpoints` using `compute_points_for_calibration()` function with `./camera_cal/calibration*.jpg`. After that, pass the values to `cv2.calibrateCamera()` function to compute the camera matrix `mtx` and distortion coefficients `dist`. Now we can correct the distortion using `corners_unwarp()` function with `mtx` and `dist`. The following is a example:

![alt text][image1]

### Pipeline (single images)

#### 1. Provide an example of a distortion-corrected image.
So far we know the camera matrix `mtx` and distortion coefficients `dist`. So a distortion-corrected image can be generated by using these values and `undistort()` function.
![alt text][image2]

#### 2. Describe how (and identify where in your code) you used color transforms, gradients or other methods to create a thresholded binary image.  Provide an example of a binary image result.

I used a combination of color and gradient thresholds to generate a binary image.
```python
def color_pipeline(img, s_thresh=(170, 255), sx_thresh=(20, 100)):
    img = np.copy(img)
    # Convert to HLS color space and separate the V channel
    hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)
    #l_channel = hls[:,:,1]
    s_channel = hls[:,:,2]
    # Sobel x
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    # Appy CLAHE algorithm to equalize contrast
    # clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(8,8))
    # gray = clahe.apply(gray)

    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0) # Take the derivative in x
    abs_sobelx = np.absolute(sobelx) # Absolute x derivative to accentuate lines away from horizontal
    scaled_sobel = np.uint8(255*abs_sobelx/np.max(abs_sobelx))
    
    # Threshold x gradient
    sxbinary = np.zeros_like(scaled_sobel)
    sxbinary[(scaled_sobel >= sx_thresh[0]) & (scaled_sobel <= sx_thresh[1])] = 1
    
    # Threshold color channel
    s_binary = np.zeros_like(s_channel)
    s_binary[(s_channel >= s_thresh[0]) & (s_channel <= s_thresh[1])] = 1
    
    # Stack each channel
    color_binary = np.dstack(( np.zeros_like(sxbinary), sxbinary, s_binary)) * 255

    # Combine the two binary thresholds
    combined_binary = np.zeros_like(sxbinary)
    combined_binary[(s_binary == 1) | (sxbinary == 1)] = 1
    return combined_binary
```
Here's an example of my output for this step.

![alt text][image3]

#### 3. Describe how (and identify where in your code) you performed a perspective transform and provide an example of a transformed image.

The code for my perspective transform includes a function called `warper()`.  The `warper()` function takes as inputs an image (`img`), as well as source (`src`) and destination (`dst`) points.  I chose the hardcode the source and destination points in the following manner:

```python
def get_image_src_dst(img):
    h, w = img.shape[0], img.shape[1]
    src = np.array([[w*0.445, h*0.627], [0, h], [w, h], [w*0.555, h*0.629]], dtype=np.float32)
    dst = np.array([[0, 0], [0, h], [w, h], [w, 0]], dtype=np.float32)
    return src, dst
```
I verified that my perspective transform was working as expected by drawing the `src` and `dst` points onto a test image and its warped counterpart to verify that the lines appear parallel in the warped image.

![alt text][image4]

#### 4. Describe how (and identify where in your code) you identified lane-line pixels and fit their positions with a polynomial?

An input image binarized by `color_pipeline()` is fitted with a 2nd order polynomial by the following function. 
```python
def fit_poly(img_shape, leftx, lefty, rightx, righty):
    left_fit = np.polyfit(lefty, leftx, 2)
    right_fit = np.polyfit(righty, rightx, 2)

    # Generate x and y values for plotting
    ploty = np.linspace(0, img_shape[0]-1, img_shape[0] )
    try:
        left_fitx = left_fit[0]*ploty**2 + left_fit[1]*ploty + left_fit[2]
        right_fitx = right_fit[0]*ploty**2 + right_fit[1]*ploty + right_fit[2]
    except TypeError:
        # Avoids an error if `left` and `right_fit` are still none or incorrect
        print('The function failed to fit a line!')
        left_fitx = 1*ploty**2 + 1*ploty
        right_fitx = 1*ploty**2 + 1*ploty
    
    return left_fitx, right_fitx, ploty, left_fit, right_fit
```
Here is a example of the fitting.

![alt text][image5]

#### 5. Describe how (and identify where in your code) you calculated the radius of curvature of the lane and the position of the vehicle with respect to center.

The code is as follows. To compute the position of the vehicle w.r.t. center, first I calculate the mid-point between the left lane and the right lane. Then, compute the distance between the mid-point and the center of the image.
```python
# Define conversions in x and y from pixels space to meters
ym_per_pix = 30/720 # meters per pixel in y dimension
xm_per_pix = 3.7/700 # meters per pixel in x dimension

def measure_curvature_real(left_fit_cr, right_fit_cr, ploty):
    # Define y-value where we want radius of curvature
    # We'll choose the maximum y-value, corresponding to the bottom of the image
    y_eval = np.max(ploty)
    
    # Calculation of R_curve (radius of curvature)
    left_curverad = ((1 + (2*left_fit_cr[0]*y_eval*ym_per_pix + left_fit_cr[1])**2)**1.5) / np.absolute(2*left_fit_cr[0])
    right_curverad = ((1 + (2*right_fit_cr[0]*y_eval*ym_per_pix + right_fit_cr[1])**2)**1.5) / np.absolute(2*right_fit_cr[0])
    
    return left_curverad, right_curverad

def vehicle_position_real(img, left_fit_cr, right_fit_cr, ploty):
    y_eval = np.max(ploty) * ym_per_pix
    left_base = left_fit_cr[0] * y_eval**2 + left_fit_cr[1] * y_eval + left_fit_cr[2]
    right_base = right_fit_cr[0] * y_eval**2 + right_fit_cr[1] * y_eval + right_fit_cr[2]
    center_cr = xm_per_pix * img.shape[1] / 2
    return center_cr - (left_base + right_base) / 2
```

#### 6. Provide an example image of your result plotted back down onto the road such that the lane area is identified clearly.

I swap the `dst` and `src` values to compute the inverse transform matrix `Minv`.
```python
def get_birds_eye_inverse_matrix(img):
    src, dst = get_image_src_dst(img)
    return cv2.getPerspectiveTransform(dst, src)

def get_image_src_dst(img):
    h, w = img.shape[0], img.shape[1]
    src = np.array([[w*0.445, h*0.627], [0, h], [w, h], [w*0.555, h*0.629]], dtype=np.float32)
    dst = np.array([[0, 0], [0, h], [w, h], [w, 0]], dtype=np.float32)
    return src, dst
```
Using `Minv` I can transform the birds-eye image to the original perspective.
```python
def back_projection(undist, warped, left_fitx, right_fitx, ploty, Minv):
    # Create an image to draw the lines on
    warp_zero = np.zeros_like(warped).astype(np.uint8)
    color_warp = np.dstack((warp_zero, warp_zero, warp_zero))

    # Recast the x and y points into usable format for cv2.fillPoly()
    pts_left = np.array([np.transpose(np.vstack([left_fitx, ploty]))])
    pts_right = np.array([np.flipud(np.transpose(np.vstack([right_fitx, ploty])))])
    pts = np.hstack((pts_left, pts_right))

    # Draw the lane onto the warped blank image
    cv2.fillPoly(color_warp, np.int_([pts]), (0,255, 0))

    # Warp the blank back to original image space using inverse perspective matrix (Minv)
    newwarp = cv2.warpPerspective(color_warp, Minv, (undist.shape[1], undist.shape[0])) 
    # Combine the result with the original image
    return cv2.addWeighted(undist, 1, newwarp, 0.3, 0)
```
Here is an example of my result on a test image:

![alt text][image6]

---

### Pipeline (video)

#### 1. Provide a link to your final video output.  Your pipeline should perform reasonably well on the entire project video (wobbly lines are ok but no catastrophic failures that would cause the car to drive off the road!).

- [project_video](./output_images/project_video_output.mp4)
- [challenge_video](./output_images/challenge_video_output.mp4)
- [harder_challenge_video](./output_images/harder_video_output.mp4)

---

### Discussion

#### 1. Briefly discuss any problems / issues you faced in your implementation of this project.  Where will your pipeline likely fail?  What could you do to make it more robust?

- As you can see in the [challenge_video](./output_images/challenge_video_output.mp4), my pipeline may fail if there is another valid "line" on the road. One idea to avoid the false detection is to restrict the distance between the detected left lane and the right lane. It would be effective because the width of the road is usually specified by law.
- My pipeline is not robust against the shade. To make the pipeline more robust, additional image processing would be promising. For example,  high-dynamic-range rendering, histogram equalization, and multi-scale retinex.
- As you can see in the [harder_challenge_video](./output_images/harder_video_output.mp4), sharp curves collapse my pipeline because the `src` and `dst` for perspective transformation are hard-coded in the pipeline. The values should be adaptively calculated by some neat algorithms.